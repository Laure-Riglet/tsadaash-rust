use chrono::{DateTime, Datelike, Duration, FixedOffset, NaiveDate};
use chrono_tz::Tz;
use std::str::FromStr;

use super::template::{RecurringRule, ScheduleTemplate};
use super::types::{AvailabilityKind, CapabilitySet, LocationConstraint};

// ========================================================================
// TIME BLOCK (Expanded output)
// ========================================================================

/// A concrete time block with absolute start/end times
/// 
/// Generated by expanding a schedule template over a date range.
#[derive(Debug, Clone, PartialEq)]
pub struct TimeBlock {
    pub start: DateTime<FixedOffset>,
    pub end: DateTime<FixedOffset>,
    pub availability: AvailabilityKind,
    pub capabilities: CapabilitySet,
    pub location_constraint: LocationConstraint,
    pub label: Option<String>,
    pub priority: i16,
}

impl TimeBlock {
    /// Check if two time blocks can be merged (same properties except time bounds)
    fn can_merge_with(&self, other: &TimeBlock) -> bool {
        self.availability == other.availability
            && self.capabilities == other.capabilities
            && self.location_constraint == other.location_constraint
            && self.priority == other.priority
            && self.label == other.label
    }
}

// ========================================================================
// EXPANSION ENGINE
// ========================================================================

/// Expand a schedule template into concrete time blocks for a date range
/// 
/// # Algorithm
/// 1. Generate all rule occurrences that overlap [range_start, range_end)
/// 2. Resolve conflicts using priority (higher wins)
/// 3. Merge adjacent blocks with identical properties
/// 4. Return sorted by start time
/// 
/// # Conflict Resolution
/// - Higher priority wins
/// - If same priority, prefer more restrictive availability:
///   Unavailable > BusyButFlexible > Available
pub fn expand_template(
    template: &ScheduleTemplate,
    range_start: DateTime<FixedOffset>,
    range_end: DateTime<FixedOffset>,
) -> Vec<TimeBlock> {
    if range_start >= range_end {
        return vec![];
    }

    // Parse timezone
    let tz = match Tz::from_str(&template.timezone) {
        Ok(tz) => tz,
        Err(_) => return vec![], // Invalid timezone, return empty
    };

    // Generate all rule occurrences
    let mut occurrences: Vec<RuleOccurrence> = vec![];
    
    for rule in &template.rules {
        let rule_occurrences = generate_rule_occurrences(rule, range_start, range_end, tz);
        occurrences.extend(rule_occurrences);
    }

    if occurrences.is_empty() {
        return vec![];
    }

    // Resolve conflicts and create segments using sweep-line algorithm
    let segments = resolve_conflicts(occurrences);

    // Merge adjacent blocks with same properties
    let merged = merge_adjacent_blocks(segments);

    merged
}

/// Internal representation of a rule occurrence
#[derive(Debug, Clone)]
struct RuleOccurrence {
    start: DateTime<FixedOffset>,
    end: DateTime<FixedOffset>,
    availability: AvailabilityKind,
    capabilities: CapabilitySet,
    location_constraint: LocationConstraint,
    label: Option<String>,
    priority: i16,
}

/// Generate all occurrences of a recurring rule within a date range
fn generate_rule_occurrences(
    rule: &RecurringRule,
    range_start: DateTime<FixedOffset>,
    range_end: DateTime<FixedOffset>,
    tz: Tz,
) -> Vec<RuleOccurrence> {
    let mut occurrences = vec![];

    // Convert range to timezone-aware dates
    let start_in_tz = range_start.with_timezone(&tz);
    let end_in_tz = range_end.with_timezone(&tz);

    // Find the date range to iterate (expand a bit to catch overnight rules)
    let start_date = start_in_tz.date_naive() - Duration::days(1);
    let end_date = end_in_tz.date_naive() + Duration::days(1);

    let mut current_date = start_date;

    while current_date <= end_date {
        let weekday = current_date.weekday();

        if rule.days.contains(&weekday) {
            // Generate occurrence(s) for this day
            let day_occurrences = generate_day_occurrence(rule, current_date, tz, range_start, range_end);
            occurrences.extend(day_occurrences);
        }

        current_date = current_date + Duration::days(1);
    }

    occurrences
}

/// Generate occurrence(s) for a single day
/// 
/// Handles overnight rules by potentially splitting into multiple occurrences
fn generate_day_occurrence(
    rule: &RecurringRule,
    date: NaiveDate,
    tz: Tz,
    range_start: DateTime<FixedOffset>,
    range_end: DateTime<FixedOffset>,
) -> Vec<RuleOccurrence> {
    let mut occurrences = vec![];

    if rule.is_overnight() {
        // Overnight rule: create one occurrence for same day and potentially one for next day
        
        // Part 1: from start time on date to midnight
        let start_dt = date.and_time(rule.start).and_local_timezone(tz).single();
        let next_day = date + Duration::days(1);
        let midnight = next_day.and_hms_opt(0, 0, 0).unwrap().and_local_timezone(tz).single();
        
        if let (Some(start), Some(mid)) = (start_dt, midnight) {
            let start_fixed = start.fixed_offset();
            let mid_fixed = mid.fixed_offset();
            
            // Check if this part overlaps with the range
            if start_fixed < range_end && mid_fixed > range_start {
                occurrences.push(RuleOccurrence {
                    start: start_fixed,
                    end: mid_fixed,
                    availability: rule.availability.clone(),
                    capabilities: rule.capabilities.clone(),
                    location_constraint: rule.location_constraint.clone(),
                    label: rule.label.clone(),
                    priority: rule.priority,
                });
            }
        }
        
        // Part 2: from midnight to end time on next day
        let end_dt = next_day.and_time(rule.end).and_local_timezone(tz).single();
        
        if let (Some(mid), Some(end)) = (midnight, end_dt) {
            let mid_fixed = mid.fixed_offset();
            let end_fixed = end.fixed_offset();
            
            // Check if this part overlaps with the range
            if mid_fixed < range_end && end_fixed > range_start {
                occurrences.push(RuleOccurrence {
                    start: mid_fixed,
                    end: end_fixed,
                    availability: rule.availability.clone(),
                    capabilities: rule.capabilities.clone(),
                    location_constraint: rule.location_constraint.clone(),
                    label: rule.label.clone(),
                    priority: rule.priority,
                });
            }
        }
    } else {
        // Normal rule: single occurrence
        let start_dt = date.and_time(rule.start).and_local_timezone(tz).single();
        let end_dt = date.and_time(rule.end).and_local_timezone(tz).single();
        
        if let (Some(start), Some(end)) = (start_dt, end_dt) {
            let start_fixed = start.fixed_offset();
            let end_fixed = end.fixed_offset();
            
            // Check if this occurrence overlaps with the range
            if start_fixed < range_end && end_fixed > range_start {
                occurrences.push(RuleOccurrence {
                    start: start_fixed,
                    end: end_fixed,
                    availability: rule.availability.clone(),
                    capabilities: rule.capabilities.clone(),
                    location_constraint: rule.location_constraint.clone(),
                    label: rule.label.clone(),
                    priority: rule.priority,
                });
            }
        }
    }

    occurrences
}

/// Resolve conflicts using a sweep-line algorithm
/// 
/// For each segment between boundaries, choose the winning rule (highest priority,
/// then most restrictive availability as tie-breaker)
fn resolve_conflicts(occurrences: Vec<RuleOccurrence>) -> Vec<TimeBlock> {
    if occurrences.is_empty() {
        return vec![];
    }

    // Collect all unique boundary points
    let mut boundaries = std::collections::BTreeSet::new();
    for occ in &occurrences {
        boundaries.insert(occ.start.timestamp());
        boundaries.insert(occ.end.timestamp());
    }

    let boundaries: Vec<i64> = boundaries.into_iter().collect();

    // For each segment between boundaries, find the winning rule
    let mut segments = vec![];

    for i in 0..boundaries.len() - 1 {
        let seg_start_ts = boundaries[i];
        let seg_end_ts = boundaries[i + 1];

        // Find all rules that cover this segment
        let mut active_rules: Vec<&RuleOccurrence> = occurrences
            .iter()
            .filter(|occ| {
                occ.start.timestamp() <= seg_start_ts && occ.end.timestamp() >= seg_end_ts
            })
            .collect();

        if !active_rules.is_empty() {
            // Sort by priority (descending), then by restrictiveness
            active_rules.sort_by(|a, b| {
                b.priority.cmp(&a.priority).then_with(|| {
                    // Tie-breaker: more restrictive availability wins
                    availability_restrictiveness(&b.availability)
                        .cmp(&availability_restrictiveness(&a.availability))
                })
            });

            let winner = active_rules[0];

            // Create segment
            // Reconstruct DateTime from timestamp
            let seg_start = DateTime::from_timestamp(seg_start_ts, 0)
                .unwrap()
                .with_timezone(&winner.start.timezone());
            let seg_end = DateTime::from_timestamp(seg_end_ts, 0)
                .unwrap()
                .with_timezone(&winner.end.timezone());

            segments.push(TimeBlock {
                start: seg_start,
                end: seg_end,
                availability: winner.availability.clone(),
                capabilities: winner.capabilities.clone(),
                location_constraint: winner.location_constraint.clone(),
                label: winner.label.clone(),
                priority: winner.priority,
            });
        }
    }

    segments
}

/// Assign a restrictiveness score to availability (higher = more restrictive)
fn availability_restrictiveness(availability: &AvailabilityKind) -> u8 {
    match availability {
        AvailabilityKind::Unavailable(_) => 2,
        AvailabilityKind::BusyButFlexible => 1,
        AvailabilityKind::Available => 0,
    }
}

/// Merge adjacent time blocks with identical properties
fn merge_adjacent_blocks(mut blocks: Vec<TimeBlock>) -> Vec<TimeBlock> {
    if blocks.is_empty() {
        return vec![];
    }

    // Sort by start time
    blocks.sort_by_key(|b| b.start.timestamp());

    let mut merged = vec![];
    let mut current = blocks[0].clone();

    for i in 1..blocks.len() {
        let next = &blocks[i];

        // Check if they're adjacent and can be merged
        if current.end == next.start && current.can_merge_with(next) {
            // Merge by extending current
            current.end = next.end;
        } else {
            // Cannot merge, push current and start new
            merged.push(current);
            current = next.clone();
        }
    }

    // Push the last block
    merged.push(current);

    merged
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::entities::schedule::types::{
        AvailabilityKind, CapabilitySet, LocationConstraint, UnavailableReason,
    };
    use chrono::{TimeZone, Timelike, Weekday};

    #[test]
    fn test_expand_empty_template() {
        let template = ScheduleTemplate::new(
            1,
            1,
            "Empty".to_string(),
            "America/New_York".to_string(),
            vec![],
        ).unwrap();

        let start = FixedOffset::east_opt(0).unwrap().with_ymd_and_hms(2026, 2, 10, 0, 0, 0).unwrap();
        let end = FixedOffset::east_opt(0).unwrap().with_ymd_and_hms(2026, 2, 11, 0, 0, 0).unwrap();

        let blocks = expand_template(&template, start, end);
        assert_eq!(blocks.len(), 0);
    }

    #[test]
    fn test_expand_simple_rule() {
        let rule = RecurringRule::new(
            vec![Weekday::Tue],
            chrono::NaiveTime::from_hms_opt(9, 0, 0).unwrap(),
            chrono::NaiveTime::from_hms_opt(17, 0, 0).unwrap(),
            AvailabilityKind::Available,
            CapabilitySet::free(),
            LocationConstraint::Any,
            Some("Work".to_string()),
            0,
        ).unwrap();

        let template = ScheduleTemplate::new(
            1,
            1,
            "Simple".to_string(),
            "America/New_York".to_string(),
            vec![rule],
        ).unwrap();

        // Tuesday Feb 10, 2026 to Wednesday Feb 11, 2026
        let start = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 10, 0, 0, 0).unwrap();
        let end = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 11, 0, 0, 0).unwrap();

        let blocks = expand_template(&template, start, end);
        
        assert_eq!(blocks.len(), 1);
        assert_eq!(blocks[0].label, Some("Work".to_string()));
        assert!(matches!(blocks[0].availability, AvailabilityKind::Available));
    }

    #[test]
    fn test_overnight_rule_expansion() {
        let rule = RecurringRule::new(
            vec![Weekday::Tue, Weekday::Wed],
            chrono::NaiveTime::from_hms_opt(23, 0, 0).unwrap(),
            chrono::NaiveTime::from_hms_opt(7, 0, 0).unwrap(),
            AvailabilityKind::Unavailable(UnavailableReason::Sleep),
            CapabilitySet::free(),
            LocationConstraint::Any,
            Some("Sleep".to_string()),
            0,
        ).unwrap();

        let template = ScheduleTemplate::new(
            1,
            1,
            "Sleep".to_string(),
            "America/New_York".to_string(),
            vec![rule],
        ).unwrap();

        // Tuesday Feb 10 to Thursday Feb 12
        let start = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 10, 0, 0, 0).unwrap();
        let end = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 12, 23, 59, 59).unwrap();

        let blocks = expand_template(&template, start, end);
        
        // Should have blocks for overnight periods
        assert!(blocks.len() >= 2);
        
        for block in &blocks {
            assert_eq!(block.label, Some("Sleep".to_string()));
        }
    }

    #[test]
    fn test_priority_conflict_resolution() {
        let base_rule = RecurringRule::new(
            vec![Weekday::Tue],
            chrono::NaiveTime::from_hms_opt(9, 0, 0).unwrap(),
            chrono::NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
            AvailabilityKind::Available,
            CapabilitySet::free(),
            LocationConstraint::Any,
            Some("Available".to_string()),
            0,
        ).unwrap();

        let override_rule = RecurringRule::new(
            vec![Weekday::Tue],
            chrono::NaiveTime::from_hms_opt(10, 0, 0).unwrap(),
            chrono::NaiveTime::from_hms_opt(11, 0, 0).unwrap(),
            AvailabilityKind::Unavailable(UnavailableReason::Work),
            CapabilitySet::free(),
            LocationConstraint::Any,
            Some("Meeting".to_string()),
            10,
        ).unwrap();

        let template = ScheduleTemplate::new(
            1,
            1,
            "Conflict Test".to_string(),
            "America/New_York".to_string(),
            vec![base_rule, override_rule],
        ).unwrap();

        // Tuesday Feb 10
        let start = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 10, 0, 0, 0).unwrap();
        let end = FixedOffset::west_opt(5 * 3600).unwrap()
            .with_ymd_and_hms(2026, 2, 11, 0, 0, 0).unwrap();

        let blocks = expand_template(&template, start, end);
        
        // Should have 3 segments: 09-10 Available, 10-11 Unavailable, 11-12 Available
        assert_eq!(blocks.len(), 3);
        
        assert_eq!(blocks[0].label, Some("Available".to_string()));
        assert!(matches!(blocks[0].availability, AvailabilityKind::Available));
        
        assert_eq!(blocks[1].label, Some("Meeting".to_string()));
        assert!(matches!(blocks[1].availability, AvailabilityKind::Unavailable(_)));
        
        assert_eq!(blocks[2].label, Some("Available".to_string()));
        assert!(matches!(blocks[2].availability, AvailabilityKind::Available));
    }

    #[test]
    fn test_merge_adjacent_blocks() {
        let tz = FixedOffset::west_opt(5 * 3600).unwrap();
        
        let block1 = TimeBlock {
            start: tz.with_ymd_and_hms(2026, 2, 10, 9, 0, 0).unwrap(),
            end: tz.with_ymd_and_hms(2026, 2, 10, 10, 0, 0).unwrap(),
            availability: AvailabilityKind::Available,
            capabilities: CapabilitySet::free(),
            location_constraint: LocationConstraint::Any,
            label: Some("Work".to_string()),
            priority: 0,
        };

        let block2 = TimeBlock {
            start: tz.with_ymd_and_hms(2026, 2, 10, 10, 0, 0).unwrap(),
            end: tz.with_ymd_and_hms(2026, 2, 10, 11, 0, 0).unwrap(),
            availability: AvailabilityKind::Available,
            capabilities: CapabilitySet::free(),
            location_constraint: LocationConstraint::Any,
            label: Some("Work".to_string()),
            priority: 0,
        };

        let merged = merge_adjacent_blocks(vec![block1, block2]);
        
        assert_eq!(merged.len(), 1);
        assert_eq!(merged[0].start.hour(), 9);
        assert_eq!(merged[0].end.hour(), 11);
    }
}
